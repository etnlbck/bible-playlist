# Mojito Logging

Mojito has its own logging system. When you call `Y.log` from within your mojits, your log messages are intercepted and processed by Mojito. This allows you some neat capabilities to provide your own log formatting, writing, and publishing functions for both your client and server runtimes. It also allows you to enable log buffering, so performance during crucial runtime periods is not distrubed.

## Log Levels

There are five log levels in Mojito:

- DEBUG
- INFO
- WARN
- ERROR
- MOJITO

All of them should be familiar except the last, which are framework-level messages that indicate that an important framework event is occurring (one that users might want to track).

Setting a log level of `WARN` will filter out all `DEBUG` and `INFO` messages, while `WARN`, `ERROR`, and `MOJITO` log messages will be processed. To see all log messages, set the log level to `DEBUG`.

#### Logs from the YUI Library

By default, all log messages generated by the YUI library itself are processed. The log level filter is also applied to these messages, but within the Mojito log output, a "YUI-" identifyer is added to them. So when YUI emits a "warn" level log message, the Mojito logs will display a "YUI-WARN" log level. This helps differenciate between application messages and YUI framework messages.

YUI logs can be turned on and off for both server and client within an application's log configuration (see below).

## Log Defaults

By default, the server and client log settings are:

- level: `DEBUG` _(log level filter)_
- yui: `true` _(whether to display YUI library logs)_
- buffer: `false` _(whether to buffer logs [see below])_
- maxBufferSize: `1024` _(how many logs the buffer holds before auto-flushing)_
- timestamp: `true` _(if true, log statements are given a timestamp)_
- defaultLevel: 'info' _(if `Y.log` is called without a log level, this is the default)_

## Log Configuration

All the values above are configurable through `application.json`. You may add a `log` config object with `server` and/or `client` values to override them like this:

    [
        {
            "settings": [ "master" ],

            "log": {
                "client": {
                    "level": "error",
                    "yui": false
                },
                "server": {
                    "level": "info",
                    "yui": false
                }
            },

            ...
        }
    ]


## Mutator Log Functions

If you want to change the format of log messages, provide a different write function (controlling where logs go), or both at the same time, you can do it. The logger has functions for _formatting_, _writing_ and _publishing_ log message that can be provided by a Mojito application. Below are these functions' signatures.

#### Custom Log Formatter

The formatter function accepts the log message, the log level, a string identifiying the source of the log (usually the YUI module name emitting the log), a timestamp, and the complete log options object. The string this function returns is given directly to the log `writer`.

    function(message, logLevel, source, timestamp, logOptions) {
        return "formatted message";
    }

#### Custom Log Writer

The writer simple accepts a string and does something with it. You can provide a function that does whatever you want with the log string. The default log writer calls `console.log`.

    function(logMessage[s]) {}

>Note: your log writer function must be able to handle a string or an array of strings. If you have set buffered logging, it may be sent an array of formatted log messages.

#### Custom Log Publisher

If a publisher is provided, it is assumed that it will take care of log formatting and writing. This is the same as providing a custom formatter and writer. It accepts the same parameters as the formatter above, and does not return a value.

    function(message, logLevel, source, timestamp, logOptions) {}

### Overriding on the Client

To provide custom log function on the client, you can simple add the following code within any JS asset loaded within your application:

    function formatter(msg, lvl, src, ts, opts) {
        return "LOG MSG: " + msg.toLowerCase() + " -[" + lvl.toUpperCase() + "]- (" + ts + ")";
    }

    YUI._mojito.logger.set('formatter', formatter);

The example above produces a log message that looks like this:

>LOG MSG: dispatcher loaded and waiting to rock! -[INFO]- (1305666208939)

The same thing can be done for the `writer` and `publisher` functions.

### Overriding on the Server

On the server, you must add your log mutator functions as the servers starts up within the `server.js` file. Here is an example:

`server.js`:

    var mojito = require('mojito'),
        fs = require('fs'),
        logPath = "/tmp/mojitolog.txt";

    function writeLog(msg) {
        fs.writeFile(logPath, msg, 'utf-8');
    }

    // you can access log formatter, writer, or publisher for the server here
    mojito.setLogWriter(function(logMessage) {
        writeLog(logMessage + '\n');
    });

    module.exports = mojito.createServer();

The `server.js` above provides a log writer that writes all logs out to the file system.

## Buffered Logs

If you don't want the performance hit of processing all your logs at the time they are emitted, you can choose to enable _buffered logs_. By specifying the `buffer` option as shown above, your logs will be cached in memory until one of two things occur:

- You programatically call `Y.log({flush: true})` for force the logs to flush
- You can set a `maxBufferSize` as a log option, and when it is reached, the logs will flush.

It is important that if you use buffers and a custom writer function, your writer function can handle not only a string parameter but an array parameter. This is because when the buffer is flushed, an array of log messages will be sent to the writer for processing.
